import React, { useState, useEffect, ChangeEvent, FormEvent } from 'react';
import { v4 as uuidv4 } from 'uuid'; // Need to install uuid: npm install uuid @types/uuid
// Assuming scoring logic is accessible (e.g., copied or imported if possible)
// If not, replace this with placeholder or fetch logic

// --- Interfaces (Match CreateGameDto structure) ---
interface InitialPlayerDto {
  user_id: string; // We'll generate this client-side for now
  player_name_in_game: string;
  player_color_in_game: string;
  player_order: number;
}

interface CreateGamePayload {
  max_money: number;
  upper_limit_of_score: number;
  lower_limit_of_score: number;
  half_money_rule: boolean;
  one_pay_all_rule?: boolean; // Match backend DTO
  five_player_mode_rule?: boolean; // Match backend DTO
  game_name?: string; // Match backend DTO
  initial_players: InitialPlayerDto[];
}

// Interface for the score preview data item
interface ScorePreviewItem {
  score: number;
  money: number;
}

// --- Default Values (Based on original Android app) ---
const defaultMaxMoney = 64;
const defaultUpperLimit = 10;
const defaultLowerLimit = 3;
const defaultHalfMoneyRule = true; // Corresponds to "Half Money After 5"
const availableColors = [
  { name: 'Red', value: '#FF0000' }, // Example hex values
  { name: 'Blue', value: '#0000FF' },
  { name: 'Yellow', value: '#FFFF00' },
  { name: 'Magenta', value: '#FF00FF' },
  { name: 'Cyan', value: '#00FFFF' },
  { name: 'Green', value: '#008000' },
  { name: 'DarkGray', value: '#A9A9A9' },
];
const defaultPlayerNames = ['Player 1', 'Player 2', 'Player 3', 'Player 4'];

// --- Component ---
const GameSetupPage: React.FC = () => {
  // --- State ---
  const [players, setPlayers] = useState(() =>
    defaultPlayerNames.map((name, index) => ({
      id: index, // Temporary ID for mapping keys
      name: name,
      color: availableColors[index % availableColors.length].value, // Assign default colors
    }))
  );

  const [gameSettings, setGameSettings] = useState({
    max_money: defaultMaxMoney,
    upper_limit_of_score: defaultUpperLimit,
    lower_limit_of_score: defaultLowerLimit,
    half_money_rule: defaultHalfMoneyRule,
    game_name: '', // Optional game name
    // Add one_pay_all_rule, five_player_mode_rule if needed
  });

  const [scorePreview, setScorePreview] = useState<string[]>([]);
  const [error, setError] = useState<string | null>(null);
  const [isLoading, setIsLoading] = useState(false);

  // --- Effects ---
  // Update score preview when settings change
  
  useEffect(() => {
    const fetchScorePreview = async () => {
      // Basic validation before fetching
       if (gameSettings.lower_limit_of_score > gameSettings.upper_limit_of_score || gameSettings.upper_limit_of_score <= 0) {
           setScorePreview(['Invalid score limits']);
           return;
       }

      // Construct query parameters
      const queryParams = new URLSearchParams({
        maxMoney: String(gameSettings.max_money),
        upperLimitOfScore: String(gameSettings.upper_limit_of_score),
        lowerLimitOfScore: String(gameSettings.lower_limit_of_score),
        halfMoneyRule: String(gameSettings.half_money_rule),
      }).toString();

      // Set loading state if desired
      // setScorePreviewLoading(true); // You'd need to add this state

      try {
        // Replace with your actual backend API URL
        const response = await fetch(`http://localhost:3000/games/score-preview?${queryParams}`);

        if (!response.ok) {
           let errorMsg = `HTTP error! status: ${response.status}`;
             try {
                const errorData = await response.json();
                errorMsg = errorData.message || JSON.stringify(errorData);
             } catch (jsonError) {
                 errorMsg = `${response.status} ${response.statusText}`;
             }
             throw new Error(errorMsg);
        }

        const data: ScorePreviewItem[] = await response.json();

        // Format the data for display
        const previewStrings = data.map(item =>
             `${item.score} Fan: $${item.money.toFixed(1)}`
        );
        setScorePreview(previewStrings);

      } catch (err: any) {
        console.error("Error fetching score preview. Raw error:", err); // Log the whole error
        // Log the specific message property seen before
        console.error("Error message property:", err.message);
        // Set a more generic error for the user, or parse if possible
        setError(`Failed to fetch preview. Status: ${err.response?.status || 'Network Error'}. Message: ${err.message}`);
        setScorePreview([`Error: ${err.message}`]);
      } finally {
        // Set loading state to false if used
        // setScorePreviewLoading(false);
      }
    };

    // Debounce or fetch directly - fetching directly for simplicity here
    fetchScorePreview();

  // Dependencies remain the same
  }, [gameSettings.max_money, gameSettings.upper_limit_of_score, gameSettings.lower_limit_of_score, gameSettings.half_money_rule]);
  

  // --- Handlers ---
  const handlePlayerNameChange = (index: number, value: string) => {
    const newPlayers = [...players];
    newPlayers[index].name = value;
    setPlayers(newPlayers);
    // Clear error when user types
    if (error) setError(null);
  };

  const handlePlayerColorChange = (index: number, value: string) => {
    const newPlayers = [...players];
    newPlayers[index].color = value;
    setPlayers(newPlayers);
  };

  const handleSettingChange = (event: ChangeEvent<HTMLSelectElement | HTMLInputElement>) => {
    const { name, value, type } = event.target;

    let processedValue: string | number | boolean = value;

    if (type === 'checkbox') {
        processedValue = (event.target as HTMLInputElement).checked;
    } else if (name === 'max_money' || name === 'upper_limit_of_score' || name === 'lower_limit_of_score') {
      processedValue = Number(value);
    } else if (name === 'half_money_rule') {
      processedValue = value === 'true'; // Assuming select value is "true" or "false"
    }

    setGameSettings(prev => ({
      ...prev,
      [name]: processedValue,
    }));
     // Clear error when user changes settings
     if (error) setError(null);
  };


  const validateInputs = (): boolean => {
    // Basic validation: check for empty names and duplicates
    const names = players.map(p => p.name.trim());
    if (names.some(name => name === '')) {
      setError('Player names cannot be empty.');
      return false;
    }
    if (new Set(names).size !== names.length) {
      setError('Player names must be unique.');
      return false;
    }
     // Check score limits
      if (gameSettings.lower_limit_of_score > gameSettings.upper_limit_of_score) {
        setError('Minimum score cannot be greater than maximum score.');
        return false;
      }


    setError(null); // Clear previous errors
    return true;
  };

  const handleSubmit = async (event: FormEvent) => {
    event.preventDefault();
    if (!validateInputs()) {
      return;
    }

    setIsLoading(true);
    setError(null);

    const payload: CreateGamePayload = {
      max_money: gameSettings.max_money,
      upper_limit_of_score: gameSettings.upper_limit_of_score,
      lower_limit_of_score: gameSettings.lower_limit_of_score,
      half_money_rule: gameSettings.half_money_rule,
      game_name: gameSettings.game_name || undefined, // Send undefined if empty
      initial_players: players.map((player, index) => ({
        user_id: uuidv4(), // Generate temporary client-side UUID
        player_name_in_game: player.name.trim(),
        player_color_in_game: player.color,
        player_order: index, // Assign order 0-3
      })),
      // Ensure optional fields are included if they have values
       // one_pay_all_rule: gameSettings.one_pay_all_rule ?? true, // Example default - Add if needed
       // five_player_mode_rule: gameSettings.five_player_mode_rule ?? false, // Example default - Add if needed
    };

    console.log("Submitting payload:", JSON.stringify(payload, null, 2)); // For debugging

    try {
      // --- TODO: Implement actual API call ---
      // Replace 'http://localhost:3000/games' with your actual backend endpoint
      const response = await fetch('http://localhost:3000/games', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(payload),
      });

      if (!response.ok) {
        // Try to get error message from backend response
        let errorMsg = `HTTP error! status: ${response.status}`;
        try {
            const errorData = await response.json();
            errorMsg = errorData.message || JSON.stringify(errorData);
        } catch (jsonError) {
             // If response is not JSON, use the status text
             errorMsg = `${response.status} ${response.statusText}`;
        }
        throw new Error(errorMsg);
      }

      const createdGame = await response.json();
      console.log('Game created successfully:', createdGame);

      // --- TODO: Implement navigation ---
      // Example: navigate(`/game/${createdGame.game_id}`); // Needs react-router-dom
      alert(`Game created! ID: ${createdGame.game_id}`); // Placeholder

    } catch (err: any) {
      console.error('Failed to create game:', err);
      setError(err.message || 'Failed to create game. Please try again.');
    } finally {
      setIsLoading(false);
    }
  };

  // --- Render ---
  return (
    <div>
      <h1>Setup New Mahjong Game</h1>
      <form onSubmit={handleSubmit}>
        {/* --- Player Setup --- */}
        <h2>Players</h2>
        {players.map((player, index) => (
          <div key={player.id} style={{ marginBottom: '10px', border: '1px solid #ccc', padding: '10px' }}>
            <label>
              Player {index + 1} Name:
              <input
                type="text"
                value={player.name}
                onChange={(e) => handlePlayerNameChange(index, e.target.value)}
                required
                style={{ marginLeft: '5px' }}
              />
            </label>
            <label style={{ marginLeft: '15px' }}>
              Color:
              <select
                value={player.color}
                onChange={(e) => handlePlayerColorChange(index, e.target.value)}
                style={{ marginLeft: '5px' }}
              >
                {availableColors.map(color => (
                  <option key={color.value} value={color.value}>
                    {color.name}
                  </option>
                ))}
              </select>
               {/* Simple color preview */}
               <span style={{
                   display: 'inline-block',
                   width: '20px',
                   height: '20px',
                   backgroundColor: player.color,
                   marginLeft: '5px',
                   border: '1px solid black',
                   verticalAlign: 'middle'
               }}></span>
            </label>
          </div>
        ))}

        {/* --- Game Rules --- */}
        <h2>Game Rules</h2>
         <div style={{ marginBottom: '10px' }}>
           <label>
             Game Name (Optional):
             <input
               type="text"
               name="game_name"
               value={gameSettings.game_name}
               onChange={handleSettingChange}
                style={{ marginLeft: '5px' }}
             />
           </label>
         </div>
        <div style={{ marginBottom: '10px' }}>
          <label>
            Max Money ($):
            <select
              name="max_money"
              value={gameSettings.max_money}
              onChange={handleSettingChange}
               style={{ marginLeft: '5px' }}
            >
              {/* Options based on original app's R.array.max_money_array */}
              <option value={16}>16</option>
              <option value={24}>24</option>
              <option value={32}>32</option>
              <option value={48}>48</option>
              <option value={64}>64</option>
              <option value={96}>96</option>
              <option value={128}>128</option>
            </select>
          </label>
        </div>
        <div style={{ marginBottom: '10px' }}>
          <label>
            Max Score (Fan):
             <select
               name="upper_limit_of_score"
               value={gameSettings.upper_limit_of_score}
               onChange={handleSettingChange}
                style={{ marginLeft: '5px' }}
             >
               {/* Generate options dynamically */}
                {[...Array(18)].map((_, i) => {
                    const score = i + 3; // Example: 3 to 20 Fan
                        return <option key={score} value={score}>{score}</option>;
                 })}
             </select>
          </label>
        </div>
         <div style={{ marginBottom: '10px' }}>
           <label>
             Min Score (Fan):
             <select
               name="lower_limit_of_score"
               value={gameSettings.lower_limit_of_score}
               onChange={handleSettingChange}
                style={{ marginLeft: '5px' }}
             >
               {/* Generate options dynamically */}
               {[...Array(5)].map((_, i) => {
                 const score = i + 1; // Example 1 to 5 Fan
                  return <option key={score} value={score}>{score}</option>;
               })}
             </select>
           </label>
         </div>
        <div style={{ marginBottom: '10px' }}>
          <label>
            Score Rule:
             <select
               name="half_money_rule"
               value={String(gameSettings.half_money_rule)} // Convert boolean to string for select
               onChange={handleSettingChange}
               style={{ marginLeft: '5px' }}
             >
                {/* Options based on original app's R.array.score_type_array */}
               <option value="true">Half Money After 5</option>
               <option value="false">Hot Hot Up (Always Half)</option>
             </select>
          </label>
        </div>
         {/* Add checkboxes/selects for one_pay_all_rule, five_player_mode_rule if implementing */}

        {/* --- Score Preview --- */}
        <h2>Score Preview</h2>
        <div style={{ border: '1px solid #eee', padding: '10px', minHeight: '100px', whiteSpace: 'pre-wrap' }}>
          {scorePreview.join('\n') || 'Select settings to see preview...'}
        </div>

        {/* --- Error Display --- */}
        {error && <p style={{ color: 'red' }}>Error: {error}</p>}

        {/* --- Submit Button --- */}
        <button type="submit" disabled={isLoading} style={{ marginTop: '20px', padding: '10px 20px' }}>
          {isLoading ? 'Creating Game...' : 'Create Game'}
        </button>
      </form>
    </div>
  );
};

export default GameSetupPage;